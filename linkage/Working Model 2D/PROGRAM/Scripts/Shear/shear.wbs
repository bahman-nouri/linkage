' ******************************************************************************
' BENDING.WBS - Bending Moment Script  
'	
' Version 0.1, Created by Knowledge Revolution
' Terry Denery and Paul Mitiguy - 1/25/96 Development Version.
' Graphing and Run controls by Paulo Raffaelli
' 
' (C) Copyright Knowledge Revolution 1996   All Rights Reserved
'
' ******************************************************************************

' *************** parameters for plotting **************************************
' *************** not all combinations have been tested !! *********************
' 
const formatstring$ = "###.#####;-###.####;0"

' plot both traces to the same scale (0 - different, 1 - same)
const sameScalingForBothPlots = 0
' plot so that y = 0 is centered vertically (0 - floats, 1 - centered)
const keepcentered = 1
' only expand the y-axis, never shrink it (0 - rescale to fit, 1 - only expand)
const rememberLimits = 1
' underline values when they are at extrema	(0 - no indication, 1 - underline)
const underlineExtrema = 1
const dataLineIndent = 12
const titleLineIndent = 6
' height of text being used for labels
dim gTextHeight& ' as Integer
dim gHalfTextHeight& ' as Integer

' ******************************************************************************
Begin Dialog WarningDialog ,,184,119,"Warning"
	OKButton 132,8,40,14
	CancelButton 132,28,40,14
	Text 12,12,104,52,"This analysis is along the x-axis of the rectangular beam.  You have chosen a beam where the dimension associated with the x-axis is shorter than that for the y-axis."
	Text 12,68,104,16,"Select OK if you wish to continue.",.Text1
	Text 12,92,104,20,"Select Cancel and rebuild beam, otherwise.",.Text2
End Dialog


	' Some global variables

	dim c_meter(100) as WMOutput
	dim a_meter as WMOutput
	dim Time_Meter as WMOutput
	dim Cp(100) as WMPoint
	dim angle_unit_to_radians as double
	dim M_units as string
	dim V_units as string
	dim SM_units as string
	dim SV_units as string
	dim SD_units as string
	dim F_Kludge as double
	dim T_Kludge as double
	dim R_Kludge as double
	dim A_Kludge as double
	dim gc as double
	dim RecWidth as double
	dim ScriptDir$ ' as string
	dim Index(100) as integer
	dim Cp_count as integer
	dim File_Counter as integer

	dim halfBodyLength as double

CONST DEBUG = 0	 	' This constant should be 0, unless debugging the Optimize code (1 for file output, 2 for file and viewport (not available on macintosh))


	' some more globals
	' set up the bending-moment stuff
	' dim d as WMDocument
	dim rec_sel as WMBody
	dim ang_rad as double
	dim length as double
	dim height as double

Type HistoryRecord
	vmin as double
	tvn as double
	fvn as double
	xvn as double
	vmax as double
	tvx as double
	fvx as double
	xvx as double
	Mmin as double
	tmn as double
	fmn as double
	xmn as double
	Mmax as double
	tmx as double
	fmx as double
	xmx as double
End Type 

Dim MMHistory as HistoryRecord

Sub ClearMaxMin
	MMHistory.vmin = 0
	MMHistory.tvn = 0
	MMHistory.fvn = 0
	MMHistory.xvn = 0
	MMHistory.vmax = 0
	MMHistory.tvx = 0
	MMHistory.fvx = 0
	MMHistory.xvx = 0 
	MMHistory.Mmin = 0 
	MMHistory.tmn = 0 
	MMHistory.fmn = 0
	MMHistory.xmn = 0 
	MMHistory.Mmax = 0 
	MMHistory.tmx = 0 
	MMHistory.fmx = 0
	MMHistory.xmx = 0 
end sub

Sub DebugPrint (message as string)
	If DEBUG>0 then
		If Basic.OS = ebWin16 or Basic.OS = ebWIn32 then
			If DEBUG=2 then
		 		ViewportOpen
				Print message
			elseIf DEBUG=1 then
				Print #1,message
			end If
		elseIf Basic.OS = ebMacintosh then
			Print #1,message
		End If
	End If
End Sub

sub GetRectangle(go as boolean, d as WMDocument, rec_sel as WMBody )
	dim b_terry as WMBody
	dim con as WMConstraint
	dim n_sel_bodies as integer			'Number of selected bodies
	dim n_select as integer
	dim n_bodies as integer
	dim n_rec as integer 				'Number of selected rectangles
	dim flex_count as integer
	dim smsg as string
	dim body_no as string

	go = false

	set d = WM.ActiveDocument


	n_sel_bodies = 0

	n_select = d.selection.count
	n_bodies = d.bodies.count
	n_rec = 0

	'Identify rectangle
	for i = 1 to d.bodies.count
		if d.bodies.item(i).kind = "rectangle" then
			n_rec = n_rec + 1
		end if
	next i

	if n_rec = 1 then
		set rec_sel = d.body("rectangle")
		go = true
	else	
		n_select = d.selection.count
		n_bodies = 0
		n_rec = 0
		for i = 1 to n_select
			if d.selection.item(i).kind = "body" then
				n_bodies = n_bodies + 1
				set b_terry = d.selection.body(n_bodies)
				if b_terry.kind = "rectangle" then
					n_rec = n_rec + 1
					set rec_sel = b_terry
				end if
				set b_terry = Nothing
			end if	   
		next i
		if n_rec = 1 then
			go = true
		end if
		if n_rec = 0 then
			msgbox "There is more than one rectangle -- you must select one"
		end if
		if n_rec > 1 then
			smsg = str(n_rec) & " rectangles selected -- you can only select one"
			msgbox smsg
		end if
	end if

end sub

Sub Constraint_Meter( theDoc as WMDocument, theBody as integer, P_output as WMOutput, Cp as WMPoint)
	'Create Meters to Measure Forces and Torque Exerted at Each Constraining Point
	set P_output = theDoc.NewOutput()
	P_output.Show = false
	P_output.format = "digital"
	P_output.column(0).label = "time"
	P_output.column(0).cell.formula = "t"
	P_output.column(1).label = "Fx"
	P_output.column(1).cell.formula = "Point["+Cstr(Cp.ID)+"].force.x"
	P_output.column(2).label = "Fy"
	P_output.column(2).cell.formula = "Point["+Cstr(Cp.ID)+"].force.y"
	P_output.column(3).label = "Torque"
	P_output.column(3).cell.formula = "Point["+Cstr(Cp.ID)+"].force.r"

End Sub


Sub CreateMeters( theDoc as WMDocument, theBody as integer)
	dim c as WMConstraint
	dim p as WMPoint

	'Identify Constraints on Selected Body and Assign a Meter to Each
	for i=1 to theDoc.constraints.count
		set c = theDoc.constraints.item(i)
		for k = 1 to c.PointCount
			set p = c.point(k)
			if p.body.ID = theBody then
				Cp_count = Cp_count + 1
				set Cp(Cp_count) = p
				Constraint_Meter theDoc, theBody, c_meter(Cp_count), cp(Cp_count)
			end if
		next k
	next i

	'Create Body Acceleration and Rotation Meters
	sform = "Body["
	sform = sform & str(theBody)
	sform = sform & "]"
	sform1 = sform & ".a.x"
	sform2 = sform & ".a.y"
	sform3 = sform & ".v.r"
	sform4 = sform & ".a.r"
	
	set a_meter = theDoc.NewOutput()
	a_meter.Show = false
	a_meter.format = "digital"
	a_meter.column(0).label = "time"
	a_meter.column(0).cell.formula = "t"
	a_meter.column(1).label = "Ax"
	a_meter.column(1).cell.formula = sform1
	a_meter.column(2).label = "Ay"
	a_meter.column(2).cell.formula = sform2
	a_meter.column(3).label = "Vr"
	a_meter.column(3).cell.formula = sform3
	a_meter.column(4).label = "Ar"
	a_meter.column(4).cell.formula = sform4

	set Time_Meter = theDoc.NewOutput()
	Time_Meter.Show = false
	Time_Meter.format = "digital"
	Time_Meter.column(0).label = "time"
	Time_Meter.column(0).cell.formula = "t"
	Time_Meter.column(1).label = "Frame"
	Time_Meter.column(1).cell.formula = "frame()"

end sub
Sub BuildIndex
	dim i as integer
	dim j as integer
	dim j_mark as integer

	/* Begin Index Build with First Two Points */
	if Cp(1).px.value < Cp(2).px.value then
		Index(1) = 1
		Index(2) = 2
	else
		Index(1) = 2
		Index(2) = 1
	end if

	for i = 3 to Cp_count
		if Cp(i).px.value < Cp(Index(1)).px.value then
			for j = 1 to i-1
				Index(i-j+1) = Index(i-j)
			next j
			Index(1) = i
		else
			j_mark = i
			for j = 1 to i-2
				if Cp(i).px.value >= Cp(Index(j)).px.value and Cp(i).px.value <= Cp(Index(j+1)).px.value then
					j_mark = j+1
				end if
			next j
			for j = j_mark to i
				Index(i-j+j_mark) = Index(i-j+j_mark-1)
			next j
			Index(j_mark) = i
		end if
	next i
end sub
Sub GetOrientation(d as WMDocument, rec_sel as WMBody, ang_rad as double, length as double, height as double)
	dim shift as double
	dim thickness as double
	dim align as boolean

	'Determine Orientation of Rectangle
	ang_rad = rec_sel.pr.value
	shift = 0.0
	length = rec_sel.width.value
	height = rec_sel.height.value
	RecWidth = length

	halfBodyLength = rec_sel.width.value / 2.0

	'Put rotation in radians
	angle_unit_to_radians = 1.0
	if ( d.RotationUnit = "degrees" ) then
		angle_unit_to_radians = Pi / 180
		ang_rad = (ang_rad - shift) * Pi / 180
	end if
	if ( d.RotationUnit = "seconds" ) then
		angle_unit_to_radians = Pi / 3600
		ang_rad = ang_rad * Pi / 3600 - shift * Pi / 180
	end if
	if ( d.RotationUnit = "minutes" ) then
		angle_unit_to_radians = Pi / 60
		ang_rad = ang_zad * Pi / 60 - shift * Pi / 180
	end if
	if ( d.RotationUnit = "revolutions" ) then
		angle_unit_to_radians = 2.0 * Pi
		ang_rad = ang_rad * 2.0 * Pi - shift * Pi / 180
	end if

end sub


const startingDataPoint = 1
const maxDataPoints = 500

Type GraphRecord
	initialized as Boolean
	minV as Double	' minimum graphed V - value
	maxV as Double	' maximum graphed V - value
	minM as Double	' minimum graphed M - value
	maxM as Double	' minimum graphed M - value
	minValueOfV as double
	maxValueOfV as double
	minValueOfM as double
	maxValueOfM as double
end type

dim graphLimits as graphRecord

function InitGraphLimits as Integer
	graphLimits.initialized = false
	graphLimits.minV = 0
	graphlimits.maxV = 0
	graphLimits.minM = 0
	graphlimits.maxM = 0
	graphLimits.minValueOfV = 0
	graphlimits.maxValueOfV = 0
	graphLimits.minValueOfM = 0
	graphlimits.maxValueOfM = 0
	InitGraph = 0
end function

const newMinV = 1
const newMaxV = 2
const newMinM = 4
const newMaxM = 8

Function UpdateLimits(ByVal aa#,ByVal bb#,ByVal cc#,ByVal dd#,ByVal v#,ByVal vv#,ByVal m#,ByVal mm#) as integer
	dim retval% ' as integer
	dim BnewMinV as boolean
	dim BnewMaxV as boolean
	dim BnewMinM as boolean
	dim BnewMaxM as boolean

	BnewMinV = false
	BnewMaxV = false
	BnewMinM = false
	BnewMaxM = false

	retval% = 0

	if (graphLimits.initialized = false) then
		if (aa < bb) then
			graphLimits.minV = aa
			'BnewMinV = true
			graphlimits.maxV = bb
  			'BnewMaxV = true
		else
			graphLimits.minV = bb
			'BnewMinV = true
			graphlimits.maxV = aa
			'BnewMaxV = true
		end if

		if (v < vv) then
			graphLimits.minValueOfV = v
			BnewMinV = true
			graphlimits.maxValueOfV = vv
  			BnewMaxV = true
		else
			graphLimits.minValueOfV = vv
			BnewMinV = true
			graphlimits.maxValueOfV = v
			BnewMaxV = true
		end if

		if (cc < dd) then
			graphLimits.minM = cc
			'BnewMinM = true
			graphlimits.maxM = dd
			'BnewMaxM = true
		else
			graphLimits.minM = cc
			'BnewMinM = true
			graphlimits.maxM = dd
			'BnewMaxM = true
		end if

		if (m < mm) then
			graphLimits.minValueOfM = m
			BnewMinM = true
			graphlimits.maxValueOfM = mm
  			BnewMaxM = true
		else
			graphLimits.minValueOfM = mm
			BnewMinM = true
			graphlimits.maxValueOfM = m
			BnewMaxM = true
		end if

		graphLimits.initialized = true
	else
		if (aa < graphLimits.minV) then
			graphLimits.minV = aa
			'BnewMinV = true
		end if

		if (bb < graphLimits.minV) then
			graphLimits.minV = bb
			'BnewMinV = true
		end if

		if (aa > graphLimits.maxV) then
			graphLimits.maxV = aa
			'BnewMaxV = true
		end if

		if (bb > graphLimits.maxV) then
			graphLimits.maxV = bb
			'BnewMaxV = true
		end if

'
		if (v <= graphLimits.minValueOfV) then
			graphLimits.minValueOfV = v
			BnewMinV = true
		end if

		if (vv <= graphLimits.minValueOfV) then
			graphLimits.minValueOfV = vv
			BnewMinV = true
		end if

		if (v >= graphLimits.maxValueOfV) then
			graphLimits.maxValueOfV = v
			BnewMaxV = true
		end if

		if (vv >= graphLimits.maxValueOfV) then
			graphLimits.maxValueOfV = vv
			BnewMaxV = true
		end if

		' and do the same for cc,dd
		if (cc < graphLimits.minM) then
			graphLimits.minM = cc
			'BnewMinM = true
		end if

		if (dd < graphLimits.minM) then
			graphLimits.minM = dd
			'BnewMinM = true
		end if

		if (cc > graphLimits.maxM) then
			graphLimits.maxM = cc
			'BnewMaxM = true
		end if

		if (dd > graphLimits.maxM) then
			graphLimits.maxM = dd
			'BnewMaxM = true
		end if

		if (m <= graphLimits.minValueOfM) then
			graphLimits.minValueOfM = m
			BnewMinM = true
		end if

		if (mm <= graphLimits.minValueOfM) then
			graphLimits.minValueOfM = mm
			BnewMinM = true
		end if

		'
		if (m >= graphLimits.maxValueOfM) then
			graphLimits.maxValueOfM = m
			BnewMaxM = true
		end if

		if (mm >= graphLimits.maxValueOfM) then
			graphLimits.maxValueOfM = mm
			BnewMaxM = true
		end if

	end if

	if (BnewMinV) then retval% = retval% + newMinV
	if (BnewMaxV) then retval% = retval% + newMaxV
	if (BnewMinM) then retval% = retval% + newMinM
	if (BnewMaxM) then retval% = retval% + newMaxM

	UpdateLimits = retval%
end function

Function TestBit(ByVal flags%,ByVal bit%) as boolean
' const newMinV = 1
' const newMaxV = 2
' const newMinM = 4
' const newMaxM = 8
	dim result as boolean

	result = false

	if (bit = newMaxM) then
		result = (flags >= newMaxM)
	else
  		if (flags >= newMaxM) then flags = flags - newMaxM

		if (bit = newMinM) then
			result = (flags >= newMinM)
		else
		 	if (flags >= newMinM) then flags = flags - newMinM

			if (bit = newMaxV) then
				result = (flags >= newMaxV)
			else
				if (flags >= newMaxV) then flags = flags - newMaxV

				if (bit = newMinV) then
					result = (flags >= newMinV)
				end if
			end if
		end if
	end if

	if (result = true) then
		i% = 0
	end if
	testbit = result

end Function

' (terry)
Type ResultRecord
 	datapoints As Integer
	dmin as double
	dmax as double
	vmin as double
	vmax as double
	Mmin as double
	Mmax as double

	xvmin as double  ' x-value where min v was seen
	xvmax as double  ' x-value where max v was seen
	xmmin as double  ' x-value where min M was seen
	xmmax as double  ' x-value where max M was seen

	d(startingDataPoint to maxDataPoints) as double
	v(startingDataPoint to maxDataPoints) as double
	M(startingDataPoint to maxDataPoints) as double
End Type 

Dim results as ResultRecord

Sub WriteExportFile
	dim aLine as string
	dim i as integer
	dim fname as string

	File_Counter = File_Counter + 1
	if (File_Counter < 10) then
		fname = "Shear00"+Cstr(File_Counter)+".dta"
	end if
	if (File_Counter >= 10 and File_Counter < 100) then
		fname = "Shear0"+Cstr(File_Counter)+".dta"
	end if
	if (File_Counter >= 100 and File_Counter < 1000) then
		fname = "Shear0"+Cstr(File_Counter)+".dta"
	end if
	Open fname For Output Access Write Shared As #1

	aLine = "Time = "+format$(Time_Meter.column(0).cell.value, "0.00e+00")+" seconds   "+"  Frame = "+format$(Time_Meter.column(1).cell.value, "####")
 	print #1, aLine
	aLine = "Position"+"         "+"Shear"+"            "+"Moment"
 	print #1, aLine

	for i = 1 to results.datapoints
		aLine = format$(results.d(i)-RecWidth/2.0,"0.000e+00")+"        "+format$(results.v(i),"0.000e+00")+"        "+format$(results.M(i),"0.000e+00")
 		print #1, aLine
	next i

	Close #1

End Sub

Function ClearResult() as integer
	results.dmin = 0
	results.dmax = 0
	results.vmin = 0
	results.vmax = 0
	results.Mmin = 0
	results.Mmax = 0
	results.datapoints = 0

	results.xvmin = 0
	results.xvmax = 0
	results.xmmin = 0
	results.xmmax = 0

	ClearResult = 1
end function

Function AddToResult(ByVal d as double, ByVal v as double, ByVal M as double) as integer

	if (results.datapoints >= maxDataPoints) then
		AddToResult = 0
	else
		inp% = startingDataPoint + results.datapoints
		results.d(inp%) = d
		results.v(inp%) = v
		results.M(inp%) = M

		if (results.datapoints = 0) then
			results.dmin = d
			results.dmax = d
			results.vmin = v
			results.vmax = v
			results.Mmin = M
			results.Mmax = M

			results.xvmin = d - halfBodyLength
			results.xmmin = d - halfBodyLength
			results.xvmax = d - halfBodyLength
			results.xmmax = d - halfBodyLength
		else
			if (results.dmin > d) then 
				results.dmin = d
			end if

			if (results.dmax < d) then 
				results.dmax = d
			end if

			if (results.vmin > v) then 
				results.vmin = v
				results.xvmin = d - halfBodyLength
			end if

			if (results.vmax < v) then 
				results.vmax = v
				results.xvmax = d - halfBodyLength
			end if

			if (results.Mmin > M) then 
				results.Mmin = M
				results.xmmin = d - halfBodyLength
			end if

			if (results.Mmax < M) then 
				results.Mmax = M
				results.xmmax = d - halfBodyLength
			end if

		end if ' not first datapoint

		results.datapoints = results.datapoints+1

		AddToResult	= 1
	end if ' number of data values within range
end function



Sub GetProfiles(d as WMDocument, rec_sel as WMBody, ang_rad as double, length as double, height as double)
	dim ax as double
	dim ay as double
	dim an as double
	dim a0 as double
	dim ar as double
    dim ai as double
    dim aj as double
	dim ajp as double
	dim rho as double
	dim v as double
	dim M as double
	dim Fx as double
	dim Fy as double
	dim T as double
	dim Xi as double
	dim dx as double
	dim xj as double
	dim x_cm as double
	dim i as integer
	dim j as integer
	dim N as integer

	' OLD: Write title and other information
    '    WriteGnuFile d  
	' 
	' OLD: Create a new file to hold the data:
 	' Open "bending.mom" for output as #1
	' new version: initialize the data-passing structure
	dummyi = ClearResult()

	'Number of elements, or prints, per beam segment
	N = 40

	'Get Acceleration normal to the line of analysis
	ax = a_meter.column(1).cell.value * A_Kludge
	ay = a_meter.column(2).cell.value * A_Kludge

	'Add in gravitational acceleration
	if d.Gravity = "linear" then
		ay = ay + d.LinearGravityConst
	end if

	an = -ax*sin(ang_rad) + ay*cos(ang_rad)

	'Get Rotational Acceleration in units of radians / s^2
	ar = a_meter.column(4).cell.value * angle_unit_to_radians
	
	'This is a Kludge to fix a bug in WMBasic which reports incorrect
	'values for rotational acceleration
	if d.RotationUnit = "degrees" then
		ar = ar * R_Kludge
	end if

	'Acceleration of left most point of beam
    a0 = an - ar * length/2.0

	'Get beam density in units of mass per beam length
	rho = rec_sel.mass.value / length

	'Initialize shear(v) and bending moment(M) to zero
	v = 0.0
	M = 0.0

	'First Line is all Zeros
	' OLD aLine = CStr(0.0) + "      " + CStr(v) + "      " + CStr(M)
	' OLD print #1, aLine
	dummyi = AddToResult( 0.0, v, M ) ' NEW

	'If not constrained at left most point, perform analysis from this point to first constraint
	if cp(Index(1)).px.value <> -length / 2.0 then
		ai = a0 	   		   ' Acceleration of left end-point of segment
		dx = (cp(Index(1)).px.value + length / 2.0 ) / N
    	for j = 1 to N  	   			' Discretize the segment
			xj = (j-0.5) * dx  			' Distance from left point of segment
			aj = ai + ar*xj	   			' Acceleration of midpoint
			ajp = ai + ar*(xj+0.5*dx)	' Acceleration at R.H.S. of element
            mass = rho * dx
            Inertia = mass*(height*height+dx*dx)/12.0
            vold = v
            v = v - mass * aj / gc
            M = M - (vold+v) * dx/ 2.0 - Inertia * ar / gc
			' OLD aLine = CStr(xj+0.5*dx) + "      " + CStr(v) + "      " + CStr(M)
			' OLD print #1, aLine
			dummyi = AddToResult( xj+0.5*dx, v, M ) ' NEW
			
		next j
	end if

	for i = 1 to Cp_count-1  ' Through each constraint point	   
		Fx = F_Kludge*c_meter(Index(i)).column(1).cell.value
		Fy = F_Kludge*c_meter(Index(i)).column(2).cell.value
		T  = T_Kludge*c_meter(Index(i)).column(3).cell.value - cp(Index(i)).py.value * ( Fx*cos(ang_rad) + Fy*sin(ang_rad) )
  
		'In case several constraints are applied at the same x-position
		while i < Cp_count-1 And cp(Index(i)).px.value = cp(Index(i+1)).px.value
			i = i + 1  
			Fx = Fx + F_Kludge*c_meter(Index(i)).column(1).cell.value
			Fy = Fy + F_Kludge*c_meter(Index(i)).column(2).cell.value
			T  = T + T_Kludge*c_meter(Index(i)).column(3).cell.value - cp(Index(i)).py.value * ( F_Kludge*c_meter(Index(i)).column(1).cell.value*cos(ang_rad) + F_Kludge*c_meter(Index(i)).column(2).cell.value*sin(ang_rad) )
		wend

		if cp(Index(i)).px.value <> cp(Index(Cp_count)).px.value then
			v  = v - Fx*sin(ang_rad) + Fy*cos(ang_rad)
			M  = M + T
			Xi = cp(Index(i)).px.value + length / 2.0
			ai = a0 + ar*Xi 	   ' Acceleration of left end-point of segment
			dx = ( cp(Index(i+1)).px.value - cp(Index(i)).px.value ) / N
			' OLD aLine = CStr(Xi) + "      " + CStr(v) + "      " + CStr(M)
			' OLD print #1, aLine

			dummyi = AddToResult( Xi, v, M ) ' NEW


    		for j = 1 to N  	   ' Discretize the segment
				xj = (j-0.5) * dx  ' Distance from left point of segment
				aj = ai + ar*xj	   ' Acceleration of midpoint
				ajp = ai + ar*(xj+0.5*dx)	' Acceleration at R.H.S. of element
            	mass = rho * dx
            	Inertia = mass*(height*height+dx*dx)/12.0
            	vold = v
            	v = v - mass * aj / gc
            	M = M - (vold+v) * dx / 2.0 - Inertia * ar / gc
				' OLD aLine = CStr(Xi+xj+0.5*dx) + "      " + CStr(v) + "      " + CStr(M)
				' OLD print #1, aLine

				dummyi = AddToResult( Xi+xj+0.5*dx, v, M ) ' NEW

			next j
		end if
	next i

	'Special Handling for the last constraint

	Fx = F_Kludge*c_meter(Index(Cp_count)).column(1).cell.value
	Fy = F_Kludge*c_meter(Index(Cp_count)).column(2).cell.value
	T  = T_Kludge*c_meter(Index(Cp_count)).column(3).cell.value - cp(Index(CP_count)).py.value * ( Fx*cos(ang_rad) + Fy*sin(ang_rad) )

	'In case several constraints are applied at the final x-position
	i = Cp_count
	if Cp_count > 1 then
		while cp(Index(i)).px.value = cp(Index(i-1)).px.value
			i = i - 1  
			Fx = Fx + F_Kludge*c_meter(Index(i)).column(1).cell.value
			Fy = Fy + F_Kludge*c_meter(Index(i)).column(2).cell.value
			T  = T + T_Kludge*c_meter(Index(i)).column(3).cell.value - cp(Index(i)).py.value * ( F_Kludge*c_meter(Index(i)).column(1).cell.value*cos(ang_rad) + F_Kludge*c_meter(Index(i)).column(2).cell.value*sin(ang_rad) )
		wend
	end if

	v = v - Fx*sin(ang_rad) + Fy*cos(ang_rad)
	M = M + T
	Xi = cp(Index(i)).px.value + length / 2.0
	ai = a0 + ar*Xi 	   ' Acceleration of left end-point of segment
	' OLD aLine = CStr(Xi)  + "      " + CStr(v) + "      " + CStr(M)
	' OLD print #1, aLine 

	dummyi = AddToResult( Xi, v, M ) ' NEW

	if cp(Index(Cp_count)).px.value <> length / 2.0 then
		dx = ( length / 2.0 - cp(Index(i)).px.value ) / N
    	for j = 1 to N	       ' Discretize the segment
			xj = (j-0.5) * dx  ' Distance from left point of segment
			aj = ai + ar*xj	   ' Acceleration of midpoint
			ajp = ai + ar*(xj+0.5*dx)	' Acceleration at R.H.S. of element
            mass = rho * dx
            Inertia = mass*(height*height+dx*dx)/12.0
            vold = v
            v = v - mass * aj / gc
            M = M - ( vold + v ) * dx / 2.0 - Inertia * ar / gc
			' OLD aLine = CStr(Xi+xj+0.5*dx) + "      " + CStr(v) + "      " + CStr(M)
			' OLD print #1, aLine

			dummyi = AddToResult( Xi+xj+0.5*dx, v, M ) ' NEW

		next j
	end if
	' OLD close #1	
end sub

	
			      
	

rem *************************************************************************
rem * Start dialog-management stuff
rem *************************************************************************
rem *************************************************************************
rem %	Integer
rem &	Long
rem #	Double
rem !	Single

Type Rect
		left As Long
		top As Long
		right As Long
		bottom As Long
End Type 

Type Point
		x As Long
		y As Long
End Type 

dim oldPoint as Point

Declare Function GetDC Pascal Lib "user32" (ByVal window&) As Long
Declare Function ReleaseDC Pascal Lib "user32" (ByVal window&,ByVal gdc&) As Long
Declare Function InvalidateRect Pascal Lib "user32" (ByVal window&, ByRef r as Rect, ByVal e as Boolean) As Boolean

Declare Function FillRect Pascal Lib "user32" (ByVal gdc&,ByRef r as Rect,ByVal gdibrush&) As Long
Declare Function FrameRect Pascal Lib "user32" (ByVal gdc&,ByRef r as Rect,ByVal gdibrush&) As Long

Declare Function MoveToEx Pascal Lib "gdi32" (ByVal gdc&,ByVal x&,ByVal y&, ByRef oldPoint as Point) As Long
Declare Function LineTo Pascal Lib "gdi32" (ByVal gdc&,ByVal x&,ByVal y&) As Boolean

Declare Function GetStockObject Pascal Lib "gdi32" (ByVal gdiobj&) As Long
Declare Function SelectObject Pascal Lib "gdi32" (ByVal gdc&,ByVal gdiobj&) As Long
Declare Function DeleteObject Pascal Lib "gdi32" (ByVal gdiobj&) As Boolean

Declare Function CreatePen Pascal Lib "gdi32" (ByVal style&,ByVal penwidth&,ByVal colorref&) As Long

Declare Function SetMapMode Pascal Lib "gdi32" (ByVal gdiobj&,ByVal mode&) As Long

' Declare Function TextOut Pascal Lib "gdi32.dll" (ByVal gdc&,ByVal x&,ByVal y&,ByVal outstr as String,ByVal nBytes&) As Boolean
Declare Function SetTextColor Pascal Lib "gdi32" (ByVal gdc&, ByVal colorref&) As Long
Declare Function GetTextExtentPoint Pascal Lib "gdi32" (ByVal gdc&, ByRef outstr as String, ByVal length%, ByRef size as Point) As Boolean



Function LoWord(dword as Long) as Integer
	LoWord = (dword mod 65536)
end Function

Function HiWord(dword as Long) as Integer
	HiWord = (dword / 65536)
end Function

dim running as Boolean
dim CurrentFrame% ' as Integer
Public BendingMomentValues() as Single
dim t as Integer

Function DoMomentDialog
	dummyi = InitGraphLimits()

    ' Display values in a dialog
	Begin Dialog FinalDialog ,,296,116,"Shear Force - Bending Moment",.MomentCallBack
		PushButton 252, 4,40,14,"Run", .RunButton
		PushButton 252,20,40,14,">",   .FwdButton
		PushButton 252,36,40,14,"<",   .BackButton
		PushButton 252,52,40,14,"Max/Min",.MaxMinButton    
		PushButton 252,68,40,14,"Export",.ExportButton    
		PushButton 252,84,40,14,"Done",.DoneButton

	
		' new : we can't output text, so we use labels
		Text        10, 10, 120, 10, "Red: Shear Force (units)",     .LabelShear  
		Text       100, 10, 120, 10, "Blue: Bending Moment (units)", .LabelMoment 

		Text		10, 10, 120, 10, "Maximums and Minimums", .MinMaxTitle

		Text		10,  25, 80,  10, "Shear Force",	.MTitle
		Text		15, 40, 200, 10, "Max = ?????? [u], t = ?????? s, frame = ???,x = ??????? m",	.MMaxLine
		Text		15, 55, 200, 10, "Min = ?????? [u], t = ?????? s, frame = ???,x = ??????? m",	.MMinLine

		Text		10,  70, 80,  10, "Bending Moment",	.VTitle
		Text		15, 85, 200, 10, "Max = ?????? [u], t = ?????? s, frame = ???,x = ??????? m",	.VMaxLine
		Text		15, 100, 200, 10, "Min = ?????? [u], t = ?????? s, frame = ???,x = ??????? m",	.VMinLine
 
	End Dialog
	running = False								     
	CurrentFrame% = 0
	dim final as FinalDialog
	dialog Final
End Function

const graphW& = 200
const graphH& = 130
const graphTop& = 45
const graphLeft& = 90

const topLabel& = 10
const bottomLabel& = 10
const leftLabel& = 80
const rightLabel& = 80
const tickLength& = 6

const penSolid = 0
const penDashed = 1
const penDot = 2

const stockBlackPen& = 7
const stockBlackBrush& = 4
const stockWhiteBrush& = 0
const stockLtGrayBrush& = 1
const stockGrayBrush& = 2
const stockDkGrayBrush& = 3

const blackColor& = 0
const redColor& = 255
const greenColor& = 65280
const blueColor& =  16711680
 

dim vTracePen& ' as Integer
dim mTracePen& ' as Integer

const vTraceColor& = redColor&
const mTraceColor& = bluecolor&

Function StupidTextOut(ByVal gdc&,ByVal color&,ByVal x&,ByVal y&,ByVal outstr$,ByVal nBytes&) As Boolean
''

if (color& = vTraceColor&) then
	if (vTracePen& <> 0) then
   		oldPen& = SelectObject(gdc&,vTracePen)
   	end if
end if
if (color& = mTraceColor&) then
	if (mTracePen& <> 0) then
   		oldPen& = SelectObject(gdc&,mTracePen)
   	end if
end if

const h& = 8
const w& = 4
const hw& = 2
const hh& = 4

'' draw
nextx& = x&
nexty& = y&

for i% = 1 to nBytes

	' extract next character
	v% = asc(mid$(outstr,i%,1))

	select case v%
		case asc("0")
			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("1")
			dummylong = MoveToEx(gdc&, nextx&+2, nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+2, nexty&+h&+1)
			' skip to next cell
			nextx& = nextx& + 6

		case asc("2")
			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+h&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("3")
			dummylong = MoveToEx(gdc&, nextx&,    nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&-1,  nexty&+h&)
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,    nexty&+hh&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("4")
			dummylong = MoveToEx(gdc&, nextx&+w&,     nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+h&)

			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,		  nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+hh&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("5")
			dummylong = MoveToEx(gdc&, nextx&+w&,     nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&-1,      nexty&+h&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("6")
			dummylong = MoveToEx(gdc&, nextx&+w&,     nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+hh&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+h&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("7")
			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&,     nexty&+h&+1)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("8")
			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,        nexty&)
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			' skip to next cell
			nextx& = nextx& + w& + 4


		case asc("9")
			dummylong = MoveToEx(gdc&, nextx&,        nexty&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&)
			dummybool =   LineTo(gdc&, nextx&+w&, nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&,    nexty&+h&)
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("-")
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			' skip to next cell
			nextx& = nextx& + w& + 4

		case asc("+")
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,        nexty&+hh&)
			dummybool = MoveToEx(gdc&, nextx&+w&, nexty&+hh&-hw&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&,    nexty&+hh&+hw&)
			' skip to next cell
			nextx& = nextx& + w& + 4
		
		case asc(".")
			' skip to next cell
			' nextx& = nextx& + 4
			dummylong = MoveToEx(gdc&, nextx&+2, nexty&+h&, oldPoint)
			dummybool =   LineTo(gdc&, nextx&+3, nexty&+h&)
			dummybool =   LineTo(gdc&, nextx&+3, nexty&+h&-1)
			dummybool =   LineTo(gdc&, nextx&+2, nexty&+h&-1)
			dummybool =   LineTo(gdc&, nextx&+2, nexty&+h&)
			' skip to next cell
			nextx& = nextx& + 8

		case asc(" ")
			' skip to next cell
			nextx& = nextx& + 2

		case else
			j% = 0	 
	end select

next i%

' dummybool = LineTo(gdc&, graphLeft&+graphW&, mappedy&)

oldPen& = SelectObject(gdc&,oldPen&)
''
end Function

Function RealStringLength(ByVal foo$) as long
	dim res as long

	res = InStr(1,foo+"[","[",0)

	if (res > 0) then
		res = res - 1
	end if
	RealStringLength = res
end function

Function PlotMoment(ByVal gdc&,ByRef aRect as Rect)
	Dim dummylong as Long
	Dim dummybool as Boolean
	Dim dummy as integer

	dim dxextent as double
	dim vyextent as double
	dim Myextent as double

	dxextent = results.dmax - results.dmin
	vyextent = results.vmax - results.vmin
	Myextent = results.Mmax - results.Mmin

	' calculate the full data range, so that
	' both plots can share the centerline and 
	' be scaled the same

	dim vMin as double
	dim vMax as double
	dim vExtent as double
	
	dim MMin as double
	dim MMax as double
	dim MExtent as double

	dim sharedMin as double
	dim sharedMax as double
	dim sharedExtent as double

	dim updates% ' as integer

	updates% = 0

	dim recalc as Boolean

	if (sameScalingForBothPlots) then
		sharedMin = results.vmin
		sharedMax = results.vmax

		if (results.Mmin < sharedMin) then sharedMin = results.Mmin
		if (results.Mmax > sharedMax) then sharedMax = results.Mmax

		'updates% = UpdateLimits(vMin,vMax,MMin,MMax)

		if (keepcentered) then
			recalc = false

			if (Abs(sharedMin) > Abs(sharedMax)) then
				sharedMax = Abs(sharedMin)
				recalc = true
			end if
			if (Abs(sharedMax) > Abs(sharedMin)) then
				sharedMin = -Abs(sharedMax)
				recalc = true
			end if
			'if (recalc = true) then
			'	dummyi% = UpdateLimits(sharedMin,sharedMax,0,0)
			'end if
		end if

		updates% = UpdateLimits(sharedMin,sharedMax,0,0,vMin,vMax,MMin,MMax)

		if (rememberLimits) then
			sharedMin = graphLimits.minV
			sharedMax = graphlimits.maxV
		end if

		sharedExtent = sharedMax - sharedMin
		
	else
		vMin = results.vmin
		vMax = results.vmax
		
		MMin = results.Mmin
		MMax = results.Mmax

		'updates% = UpdateLimits(vMin,vMax,MMin,MMax)

		if (keepcentered) then
			recalc = false

			if (Abs(vMin) > Abs(vMax)) then
				vMax = Abs(vMin)
				recalc = true
			end if
			if (Abs(vMax) > Abs(vMin)) then
				vMin = -Abs(vMax)
				recalc = true
			end if

			if (Abs(MMin) > Abs(MMax)) then
				MMax = Abs(MMin)
				recalc = true
			end if
			if (Abs(MMax) > Abs(MMin)) then
				MMin = -Abs(MMax)
				recalc = true
			end if
			
			'if (recalc = true) then
			'	dummyi% = UpdateLimits(vMin,vMax,MMin,MMax)
			'end if
		end if

		updates% = UpdateLimits(vMin,vMax,MMin,MMax,vMin,vMax,MMin,MMax)

		if (rememberLimits) then
			vMin = graphLimits.minV
			vMax = graphlimits.maxV
			MMin = graphLimits.minM
			MMax = graphlimits.maxM
		end if

		vExtent = vMax - vMin

		MExtent = MMax - MMin
	end if

	' draw the y- tick marks
	' draw the y- labels

	' draw the graph itself

	dim drawline as Boolean
	dim temp as double
	dim underline as Boolean
	dim oldPoint as Point

	' draw the x-axis
	if (sameScalingForBothPlots) then
		mappedy& = ((-sharedMin / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		
		if ((mappedy& > graphTop&) and (mappedy& < graphTop&+graphH&-1)) then
			blackPen& = GetStockObject(stockBlackPen&)
			oldPen& = SelectObject(gdc&,blackPen&)
			dummylong = MoveToEx(gdc&, graphLeft&, mappedy&, oldPoint)
			dummybool = LineTo(gdc&, graphLeft&+graphW&, mappedy&)
			oldPen& = SelectObject(gdc&,oldPen&)
		end if
   else
		mappedy& = ((-vMin / vExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		
		if ((mappedy& > graphTop&) and (mappedy& < graphTop&+graphH&-1)) then
			blackPen& = GetStockObject(stockBlackPen&)
			oldPen& = SelectObject(gdc&,blackPen&)
			dummylong = MoveToEx(gdc&, graphLeft&, mappedy&, oldPoint)
			dummybool = LineTo(gdc&, graphLeft&+graphW&, mappedy&)
			oldPen& = SelectObject(gdc&,oldPen&)
		end if

		mappedy& = ((-MMin / MExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		
		if ((mappedy& > graphTop&) and (mappedy& < graphTop&+graphH&-1)) then
			blackPen& = GetStockObject(stockBlackPen&)
			oldPen& = SelectObject(gdc&,blackPen&)
			dummylong = MoveToEx(gdc&, graphLeft&, mappedy&, oldPoint)
			dummybool = LineTo(gdc&, graphLeft&+graphW&, mappedy&)
			oldPen& = SelectObject(gdc&,oldPen&)
		end if
    end if

   	' force labels
	underline = false

	if (sameScalingForBothPlots) then
		mappedy& = (((results.vmin-sharedMin) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMinV%)) then underline = true
	else
		mappedy& = (((results.vmin-vMin) / vExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMinV%)) then underline = true
	end if

   	if ((mappedy& > graphTop) and (mappedy& <= graphTop&+graphH&-1)) then
   		if (vTracePen& <> 0) then
   			oldPen = SelectObject(gdc&,vTracePen)
   		end if

   		dummylong = MoveToEx(gdc&, graphLeft&, mappedy&, oldPoint)
   		dummybool = LineTo(gdc&, graphLeft&-tickLength, mappedy&)

		if (underline) then
   			dummylong = MoveToEx(gdc&, graphLeft&-leftLabel&+4,mappedy&+gHalfTextHeight&, oldPoint)
   			dummybool = LineTo(gdc&, graphLeft&-tickLength&-4, mappedy&+gHalfTextHeight&)
		end if

   		if (vTracePen& <> 0) then
   			oldPen = SelectObject(gdc&,oldPen&)
   		end if
	
   		ts! = results.vmin
   		s1$ = Format$(ts!,formatstring$)

   		oldColor& = SetTextColor(gdc&,vTraceColor&)

		dim aargh as long

		aargh = 	RealStringLength(s1$)

   		' dummyb = TextOut(gdc&,graphLeft&-leftLabel&+4,mappedy&-gHalfTextHeight&,s1$,aargh)

		dummyb = StupidTextOut(gdc&,vTraceColor&,graphLeft&-leftLabel&+4,mappedy&-gHalfTextHeight&,s1$,aargh)

   		oldColor = SetTextColor(gdc&,oldColor&)
   	else
   		i% = 0
   	end if

	firstmappedy& = mappedy&

	underline = false
	if (sameScalingForBothPlots) then
		mappedy& = (((results.vmax-sharedMin) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMaxV%)) then underline = true
	else
		mappedy& = (((results.vmax-vMin) / vExtent) * -(graphH&-2)) + graphTop + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMaxV%)) then underline = true
	end if

	if ((mappedy& > graphTop) and (mappedy& <= graphTop+graphH&-1)) then
		if (vTracePen& <> 0) then
			oldPen = SelectObject(gdc&,vTracePen)
		end if

		dummylong = MoveToEx(gdc&, graphLeft&, mappedy&, oldPoint)
		dummybool = LineTo(gdc&, graphLeft&-tickLength&, mappedy&)

		' if the labels would overlap, then displace the second label
		if ((mappedy& >= firstmappedy&-gTextHeight&) and (mappedy& <= firstmappedy&+gTextHeight&)) then
			mappedy& = firstmappedy&-gTextHeight&
		end if

		if (underline) then
   			dummylong = MoveToEx(gdc&, graphLeft&-leftLabel&+4,mappedy&+gHalfTextHeight&, oldPoint)
   			dummybool = LineTo(gdc&, graphLeft&-tickLength&-4, mappedy&+gHalfTextHeight&)
		end if

		if (vTracePen& <> 0) then
			oldPen = SelectObject(gdc&,oldPen&)
		end if

		ts! = results.vmax
		s1$ = Format$(ts!,formatstring$)
		if (s1$ = ".") then 
			s1$ = "0"
		end if

		oldColor = SetTextColor(gdc&,vTraceColor&)
		
		' if the labels would overlap, then displace the second label
		if ((mappedy& >= firstmappedy&-gTextHeight&) and (mappedy& <= firstmappedy&+gTextHeight&)) then
			mappedy& = firstmappedy&-gTextHeight&
		end if
	
'??'		dummyb = TextOut(gdc&,graphLeft&-leftLabel&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))
		dummyb = StupidTextOut(gdc&,vTraceColor&,graphLeft&-leftLabel&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))

		oldColor = SetTextColor(gdc&,oldColor&)
	else
		i% = 0
	end if

	' torque labels
	if (sameScalingForBothPlots) then
		mappedy& = (((results.Mmin-sharedMin) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMinM%)) then underline = true
	else
		mappedy& = (((results.Mmin-MMin) / MExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMinM%)) then underline = true
	end if

	if ((mappedy& > graphTop&) and (mappedy& <= graphTop&+graphH&-1)) then
		if (mTracePen& <> 0) then
			oldPen = SelectObject(gdc&,mTracePen&)
		end if

		dummylong = MoveToEx(gdc&, graphLeft&+graphW&, mappedy&, oldPoint)
		dummybool = LineTo(gdc&, graphLeft&+graphW&+tickLength, mappedy&)

		if (underline) then
   			dummylong = MoveToEx(gdc&, graphLeft&+graphW&+4,mappedy&+gHalfTextHeight&, oldPoint)
   			dummybool = LineTo(gdc&, graphLeft&+graphW&+leftLabel&-4, mappedy&+gHalfTextHeight&)
		end if

		if (mTracePen& <> 0) then
			oldPen = SelectObject(gdc&,oldPen&)
		end if

		ts! = results.Mmin
		s1$ = Format$(ts!,formatstring$)
	
		oldColor = SetTextColor(gdc&,mTraceColor&)
'??'		dummyb = TextOut(gdc&,graphLeft&+graphW&+tickLength&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))
		dummyb = StupidTextOut(gdc&,mTraceColor&,graphLeft&+graphW&+tickLength&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))
		oldColor = SetTextColor(gdc&,oldColor&)
	else
		i% = 0
	end if

	firstmappedy& = mappedy&

	underline = false
	if (sameScalingForBothPlots) then
		mappedy& = (((results.Mmax-sharedMin) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMaxM%)) then underline = true
	else
		mappedy& = (((results.Mmax-MMin) / MExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		if (underlineExtrema and TestBit(updates%, newMaxM%)) then underline = true
	end if

	if ((mappedy& > graphTop&) and (mappedy& <= graphTop&+graphH&-1)) then
		if (mTracePen& <> 0) then
			oldPen = SelectObject(gdc&,mTracePen&)
		end if

		dummylong = MoveToEx(gdc&, graphLeft&+graphW&, mappedy&, oldPoint)
		dummybool = LineTo(gdc&, graphLeft&+graphW&+tickLength&, mappedy&)

		' if the labels would overlap, then displace the second label
		if ((mappedy& >= firstmappedy&-gTextHeight&) and (mappedy& <= firstmappedy&+gTextHeight&)) then
			mappedy& = firstmappedy&-gTextHeight&
		end if

		if (underline) then
   			dummylong = MoveToEx(gdc&, graphLeft&+graphW&+4,mappedy&+gHalfTextHeight, oldPoint)
   			dummybool = LineTo(gdc&, graphLeft&+graphW&+leftLabel&-4, mappedy&+gHalfTextHeight&)
		end if

		if (mTracePen& <> 0) then
			oldPen = SelectObject(gdc&,oldPen&)
		end if

		ts! = results.Mmax
		s1$ = Format$(ts!,formatstring$)
		if (s1$ = ".") then 
			s1$ = "0"
		end if

		oldColor = SetTextColor(gdc&,mTraceColor&)

		' if the labels would overlap, then displace the second label
		if ((mappedy& >= firstmappedy&-gTextHeight&) and (mappedy& <= firstmappedy&+gTextHeight&)) then
			mappedy& = firstmappedy&-gTextHeight&
		end if

'??'		dummyb = TextOut(gdc&,graphLeft&+graphW&+tickLength&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))
		dummyb = StupidTextOut(gdc&,mTraceColor&,graphLeft&+graphW&+tickLength&+4,mappedy&-gHalfTextHeight&,s1$,RealStringLength(s1$))
		oldColor = SetTextColor(gdc&,oldColor&)
	else
		i% = 0
	end if



	' Trace one	(v values)

	drawline = false

	if (vTracePen& <> 0) then
		oldPen = SelectObject(gdc&,vTracePen&)
	end if

	for x% = startingDataPoint to startingDataPoint+results.datapoints-1
		mappedx& = (((results.d(x%)-results.dmin) / dxextent) * graphW&) + graphLeft&

		if (sameScalingForBothPlots) then
			mappedy& = (((results.v(x%)-sharedMin) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		else
			mappedy& = (((results.v(x%)-vMin) / vExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		end if

		if (drawline = true) then
			dummybool = LineTo(gdc&, mappedx&, mappedy&)
		else
			dummylong = MoveToEx(gdc&, mappedx&, mappedy&, oldPoint)
			drawline = true
		end if

	next x%

	if (vTracePen& <> 0) then
		dummyi = SelectObject(gdc&,oldPen&)
	end if

	' Trace two	(M-values)

	drawline = false

	if (mTracePen <> 0) then
		oldPen = SelectObject(gdc&,mTracePen&)
	end if

	for x% = startingDataPoint to startingDataPoint+results.datapoints-1
		
		mappedx& = ((((results.d(x%)-results.dmin)) / dxextent) * graphW&) + graphLeft
		
		if (sameScalingForBothPlots) then
			mappedy& = ((((results.M(x%)-sharedMin)) / sharedExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		else
			mappedy& = ((((results.M(x%)-MMin)) / MExtent) * -(graphH&-2)) + graphTop& + graphH& - 1
		end if

		if (drawline = true) then
			if (mappedy& < graphTop + graphH&) then
				dummybool = LineTo(gdc&, mappedx&, mappedy&)
			end if
		else
			dummylong = MoveToEx(gdc&, mappedx&, mappedy&, oldPoint)
			drawline = true
		end if

	next x%

	if (mTracePen& <> 0) then
		dummyi = SelectObject(gdc&,oldPen&)
	end if
End Function

' dim dialogDC as Integer
Dim AString as String
Dim WorkWindow As HWND

Function ShowMoment()
	Dim dummy as Long
	Dim dummyi as Integer
	Dim dummyb as Boolean

	Dim aRect as Rect

	'	WinActivate(AString)
	' Dim dialogDC as Integer
	dialogDC& = GetDC(WorkWindow.Value)
	' dummyi = SetMapMode(dialogDC&,1)

	aRect.left = graphLeft& - leftLabel&
	aRect.top =	 graphTop& - topLabel&
	aRect.right = aRect.left + leftLabel& + graphW& + rightLabel&
	aRect.bottom = aRect.top + topLabel& + graphH& + bottomLabel&

	dummyi = FillRect(dialogDC&,aRect,GetStockObject(stockWhiteBrush))
	dummyi = FrameRect(dialogDC&,aRect,GetStockObject(stockBlackBrush))

	aRect.left = graphLeft
	aRect.top =	 graphTop
	aRect.right = aRect.left + graphW&
	aRect.bottom = aRect.top + graphH&

	dummyi = FrameRect(dialogDC&,aRect,GetStockObject(stockBlackBrush))

    dim oldColor& ' as long
	dim label$ ' as String
	dim llength& ' as integer
	dim textext& ' as long

	blackPen& = GetStockObject(stockBlackPen)
	oldPen& = SelectObject(dialogDC&,blackPen&)

	dummylong = MoveToEx(dialogDC&, aRect.left, aRect.bottom, oldPoint)
	dummybool = LineTo(dialogDC&, aRect.left, aRect.bottom+4)

	dummylong = MoveToEx(dialogDC&, (aRect.left+aRect.right)/2, aRect.bottom, oldPoint)
	dummybool = LineTo(dialogDC&, (aRect.left+aRect.right)/2, aRect.bottom+4)

	dummylong = MoveToEx(dialogDC&, aRect.right-1, aRect.bottom, oldPoint)
	dummybool = LineTo(dialogDC&, aRect.right-1, aRect.bottom+4)

	oldPen& = SelectObject(dialogDC&,oldPen&)

	if (vTracePen = 0) then
		' solid red pen
		vTracePen = CreatePen(0,0,vTraceColor&)
	end if
	
	if (mTracePen = 0) then
		' solid blue pen
		mTracePen = CreatePen(0,0,mTraceColor&)
	end if


	oldColor& = SetTextColor(dialogDC&,vTraceColor&)
	label$ = "Force in " + V_Units
	llength& = RealStringLength(label$)
	'??'	dummyb = TextOut(dialogDC&,graphLeft&-leftLabel&+4,graphTop&-topLabel&+4,label$,llength&)
	dummyb = StupidTextOut(dialogDC&,vTraceColor&,graphLeft&-leftLabel&+4,graphTop&-topLabel&+4,label$,llength&)
	oldColor& = SetTextColor(dialogDC&,oldColor&)

	oldColor& = SetTextColor(dialogDC&,mTraceColor&)
	label$ = "Moment in " + M_Units
	llength& = RealStringLength(label$)

	gTextHeight& = 10
	gHalfTextHeight& = 5

	'??' dummyb = GetTextExtentPoint(dialogDC&,label$,llength&,oldPoint)

	'??' if (gTextHeight& = 0) then
	'??' 	gTextHeight& = oldPoint.y
	'??' 	gHalfTextHeight& = (gTextHeight& + 1) / 2
	'??'  end if
	'??' dummyb = TextOut(dialogDC&,graphLeft+graphW&+rightLabel-4-LoWord(textext),graphTop-topLabel+4,label$,llength&)
	dummyb = StupidTextOut(dialogDC&,mTraceColor&,graphLeft+graphW&+rightLabel-4-LoWord(textext),graphTop-topLabel+4,label$,llength&)
	
	oldColor& = SetTextColor(dialogDC&,oldColor&)

	dummyi = PlotMoment(dialogDC&,aRect)

	dummyi = ReleaseDC(WorkWindow.Value,dialogDC&)

End Function

dim dialogInitialized as Boolean
dim singleStep as Boolean
dim runForward as Boolean
dim showingMaxMin as Boolean

Sub TurnItOff
	DlgVisible "LabelShear",1
	DlgVisible "LabelMoment",1

	DlgVisible "MinMaxTitle",0

	DlgVisible "MTitle",0
	DlgVisible "MMaxLine",0
	DlgVisible "MMinLine",0

	DlgVisible "VTitle",0
	DlgVisible "VMaxLine",0
	DlgVisible "VMinLine",0
End Sub

Sub TurnItOn
	DlgVisible "LabelShear",0
	DlgVisible "LabelMoment",0

	DlgVisible "MinMaxTitle",1

	DlgVisible "MTitle",1
	DlgVisible "MMaxLine",1
	DlgVisible "MMinLine",1

	DlgVisible "VTitle",1
	DlgVisible "VMaxLine",1
	DlgVisible "VMinLine",1
End Sub

Sub ShowMaxMin
	dim label$ ' as String
	dim value$ ' as String

	Dim aRect as Rect

	aRect.left = graphLeft& - leftLabel&
	aRect.top =	 graphTop& - topLabel&
	aRect.right = aRect.left + leftLabel& + graphW& + rightLabel&
	aRect.bottom = aRect.top + topLabel& + graphH& + bottomLabel&

	if (WorkWindow is not nothing) then
		dialogDC& = GetDC(WorkWindow.Value)
		dummyi = FillRect(dialogDC&,aRect,GetStockObject(stockGrayBrush))
		dummyi = ReleaseDC(WorkWindow.Value,dialogDC&)
	end if

	TurnItOn

	DlgText "MTitle", "Shear Force"
	DlgText "VTitle", "Bending Moment"

	value$ = Format$(MMHistory.MMax,"0.00e+00")
	label$ = "Max = " + value$ + " " + SM_Units$
	value$ = Format$(MMHistory.tMx,"#0.000")
	label$ = label$ + ", t = " + value$ + " s, frame = " 
	value$ = Format$(MMHistory.fMx,"####0")
	label$ = label$ + value$ + ", x = "
	value$ = Format$(MMHistory.xmx,"#0.00")
	label$ = label$ + value$
	label$ = label$ + " " + SD_Units
	DlgText "MMaxLine",label$

	value$ = Format$(MMHistory.MMin,"0.00e+00")
	label$ = "Min = " + value$ + " " + SM_Units$
	value$ = Format$(MMHistory.tMn,"#0.000")
	label$ = label$ + ", t = " + value$ + " s, frame = " 
	value$ = Format$(MMHistory.fMn,"####0")
	label$ = label$ + value$ + ", x = "
	value$ = Format$(MMHistory.xmn,"#0.00")
	label$ = label$ + value$
	label$ = label$ + " " + SD_Units
	DlgText "MMinLine",label$

	value$ = Format$(MMHistory.Vmax,"0.00e+00")
	label$ = "Max = " + value$ + " " + SV_Units$
	value$ = Format$(MMHistory.tvx,"#0.000")
	label$ = label$ + ", t = " + value$ + " s, frame = " 
	value$ = Format$(MMHistory.fvx,"####0")
	label$ = label$ + value$ + ", x = "
	value$ = Format$(MMHistory.xvx,"#0.00")
	label$ = label$ + value$
	label$ = label$ + " " + SD_Units
	DlgText "VMaxLine",label$

	value$ = Format$(MMHistory.VMin,"0.00e+00")
	label$ = "Min = " + value$ + " " + SV_Units$
	value$ = Format$(MMHistory.tvn,"#0.000")
	label$ = label$ + ", t = " + value$ + " s, frame = " 
	value$ = Format$(MMHistory.fvn,"####0")
	label$ = label$ + value$ + ", x = "
	value$ = Format$(MMHistory.xvn,"#0.00")
	label$ = label$ + value$
	label$ = label$ + " " + SD_Units
	DlgText "VMinLine",label$

End Sub


Sub EvaluateMaxMin

	if ( MMHistory.Mmax < results.Mmax ) then
		MMHistory.Mmax = results.Mmax
		MMHistory.tmx = Time_Meter.column(0).cell.value
		MMHistory.fmx = Time_Meter.column(1).cell.value
		MMHistory.xmx = results.xmmax
	end if
	if ( MMHistory.Mmin > results.Mmin ) then
		MMHistory.Mmin = results.Mmin
		MMHistory.tmn = Time_Meter.column(0).cell.value
		MMHistory.fmn = Time_Meter.column(1).cell.value
		MMHistory.xmn = results.xmmin
	end if
	if ( MMHistory.vmax < results.vmax ) then
		MMHistory.vmax = results.vmax
		MMHistory.tvx = Time_Meter.column(0).cell.value
		MMHistory.fvx = Time_Meter.column(1).cell.value
		MMHistory.xvx = results.xvmax
	end if
	if ( MMHistory.vmin > results.vmin ) then
		MMHistory.vmin = results.vmin
		MMHistory.tvn = Time_Meter.column(0).cell.value
		MMHistory.fvn = Time_Meter.column(1).cell.value
		MMHistory.xvn = results.xvmin
	end if

End Sub

Function MomentCallBack (ID as string, Action as integer, SuppValue as integer)

	' DebugPrint "In callback, action: "+str$(action)+" ID"+ID
	Select Case Action
		Case 1 					' Initialization
			dialogInitialized = false
			singleStep = false
			runForward = false
			running = false
			DlgEnable "BackButton",(currentFrame% > 0)

			DlgText "LabelShear","Red: Shear in " + V_units
			DlgText "LabelMoment","Blue: Moment in " + M_units

			TurnItOff
			showingMaxMin = false
			
		Case 2					' Control was chosen
			MomentCallBack = 1
			if (ID = "DoneButton") then
				MomentCallBack = 0
			elseif (dialogInitialized = true) then
				if (running = false) then
					if (ID = "MaxMinButton") then
						' show the max/min headings
						TurnItOn
						ShowMaxMin
						showingMaxMin = true
					elseif (showingMaxMin = true) then
						' hide the max/min labels

						' show the shear and moment
						TurnItOff
						dummyi = ShowMoment()
						showingMaxMin = false
					end if
				end if

				if (running = False) then
					if (ID = "ExportButton") then
					   ' (terry) export code goes in here
						WriteExportFile
					elseif (ID = "RunButton") then
						running = true
						singleStep = false
						runForward = true
					elseif (ID = "FwdButton") then
						running = true
						singleStep = true
						runForward = true
					elseif (ID = "BackButton") then
						running = true
						singleStep = true
						runForward = false
					end if

					if (running = true) then
						DlgText "RunButton", "Stop"
						DlgFocus "RunButton"
						' (terry) disable '<', '>' and 'export'
						if (singleStep <> true) then
							DlgEnable "FwdButton",0
							DlgEnable "BackButton",0
						end if
						DlgEnable "MaxMinButton",0
						DlgEnable "ExportButton",0
						DlgEnable "DoneButton",0
					end if
				else
					running = False
					if (ID = "RunButton") then
						DlgText "RunButton", "Run"
						' (terry) enable '<', '>' and 'export'
						DlgEnable "FwdButton",1
						DlgEnable "BackButton",(currentFrame% > 0)
						DlgEnable "MaxMinButton",1
						DlgEnable "ExportButton",1
						DlgEnable "DoneButton",1
					end	if
 				end	if

			end if
		Case 3					' Control was chosen
		Case 4					' Control was chosen
		Case 5					' Idle: return non-zero value to keep idling
			if (dialogInitialized = false) then
			
				AString = "Working Model|Bending Moment"
				Set WorkWindow = WinFind(AString)
				If (WorkWindow Is Not Nothing) Then
					WinActivate(AString)
					dialogDC& = GetDC(WorkWindow.Value)
					dummyi = ReleaseDC(WorkWindow.Value,dialogDC&)
					if (dialogDC& <> 0) then dialogInitialized = true
				end if
			end if

			if (dialogInitialized = true) then
				if (running = True)	then
					' Calculate a frame, run the moment bending script
					Dim d as WMDocument
					Set d = WM.ActiveDocument
					CurrentFrame% = D.CurrentFrame

					'
					if (runForward) then
						d.run 1
					else
						d.run -1
					end if

					CurrentFrame% = d.CurrentFrame

					if (singleStep = true) then
						running = false
						singleStep = false
						DlgText "RunButton", "Run"
						' (terry) enable '<', '>' and 'export'
						DlgEnable "FwdButton",1
						DlgEnable "BackButton",(currentFrame% > 0)
						DlgEnable "MaxMinButton",1
						DlgEnable "ExportButton",1
						DlgEnable "DoneButton",1
					end if


					' run the bending-moment script

					GetOrientation d, rec_sel, ang_rad, length, height
					GetProfiles d, rec_sel, ang_rad, length, height
					EvaluateMaxMin

					dummyi = ShowMoment()		
				
				end if
			end if
			MomentCallBack = 1
		'Case 6					' Control was chosen
	End Select

end Function

Sub Main()
	dim d1 as WarningDialog
	dim tok as integer
	dim i as integer
	dim i_begin as integer
	dim i_finish as integer
	dim os as string
	dim Bend_go as boolean
    Dim id as variant
	dim d as WMDocument		: set d = WM.ActiveDocument


	Cp_count = 0
	File_Counter = 0
	tok = 1

	'Determine Which Operating System you are Using
	If Basic.OS = ebWin16 or Basic.OS = ebWIn32 then		' running MS-Windows
		os = "win"
	elseIf Basic.OS = ebMacintosh then			   			' running Macintosh
 		os = "mac"
	else 
		If Msgbox("Unknown Operating System:  Continue Anyway?",1)=2 then	' Quit
			End
		End If
	End If

	'Identify Name of Script Directory
	If os="win" then
		WMDir$ = Basic.HomeDir$		' AppFilename$ not supported, hoping Basic will always reside with WM
		ScriptDir$ = WMDir$+"\scripts\krdemos\"
		DebugPrint "Scripts dir:"+ScriptDir$
	else				' macintosh
		WMDir$ = Basic.HomeDir$		' AppFilename$ not supported, hoping Basic will always reside with WM
		ScriptDir$ = WMDir$+":scripts:krdemos:"
		DebugPrint "Scripts dir:"+ScriptDir$
	end If

	'Identify rigid rectangular body to be made flexible
	
	GetRectangle Bend_go, d, rec_sel

	GetOrientation d, rec_sel, ang_rad, length, height

	if height > length then
		tok = dialog(d1)
	end if
	if tok = 0 then
		Bend_go = false
	end if

	'If selected body found, analyze beam
	if Bend_go = true then

		'Establish appropriate unit system
		if mid(d.ForceUnit, 1, 2) = "ne" then
   			d.MassUnit = "Kilograms"
   			d.DistanceUnit = "meters"
   			d.ForceUnit = "Newtons"
			V_units = "Newtons"
			SV_units = "N"
			M_units = "Newton-Meters"
			SM_units = "N-m"
			SD_Units = "m"
			F_Kludge = 1.0
			T_Kludge = 1.0
			R_Kludge = Pi / 180.0
			A_Kludge = 1.0
			gc = 1.0
		else
			if mid(d.ForceUnit, 1, 2) = "po" then
   				d.MassUnit = "Earth Pounds"
   				d.DistanceUnit = "inches"
   				d.ForceUnit = "Pounds"
				V_units = "Pounds"
				SV_units = "lb"
				M_units = "Inch-Pounds"
				SM_units = "in-lb"
				SD_Units = "in"
				F_Kludge = 4.448194255
				T_Kludge = 0.112984829
				A_Kludge = 0.025399986
				R_Kludge = Pi / 180.0
				gc = 386.04 'lbm-in/s^2-lbf
			else 
				Bend_go = false
				msgbox "This script will run with the force units, pounds and Newtons only, not " + d.ForceUnit
			end if
		end if

	end if

	'Continue if the unit system is SI or English
	if Bend_go = true then

		' SET UP

		'Create meters

		CreateMeters d, rec_sel.ID

		if Cp_count > 1 then
			BuildIndex
		else
			Index(1) = 1
		end if

        d.reset

		'Initialize Max/Min History Structure
		ClearMaxMin

		' RUN
		dummyi = DoMomentDialog()

		d.reset

		' CLEAN UP
		d.selectall false
		for i = 1 to Cp_count
			d.select c_meter(Cp_count-i+1)
			d.delete
   		next i
		d.select a_meter
		d.delete
		d.select Time_Meter
		d.delete

	end if

End Sub
